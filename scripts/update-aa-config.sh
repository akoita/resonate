#!/usr/bin/env bash
# update-aa-config.sh - Parse Forge deployment output and update .env files
#
# This script reads the latest deployment broadcast JSON and updates
# backend/.env with the deployed contract addresses.
#
# Usage: ./scripts/update-aa-config.sh

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
BROADCAST_FILE="$PROJECT_ROOT/contracts/broadcast/DeployLocalAA.s.sol/31337/run-latest.json"
BACKEND_ENV="$PROJECT_ROOT/backend/.env"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo "=== Updating AA Configuration ==="
echo ""

# Check if broadcast file exists
if [[ ! -f "$BROADCAST_FILE" ]]; then
    echo "Error: No deployment broadcast found at:"
    echo "  $BROADCAST_FILE"
    echo ""
    echo "Run 'make local-aa-deploy' first."
    exit 1
fi

# Extract addresses from broadcast JSON using jq
if ! command -v jq &> /dev/null; then
    echo "Error: 'jq' is required but not installed."
    echo "Install with: sudo apt install jq  (or brew install jq on macOS)"
    exit 1
fi

# Parse the JSON to get deployed contract addresses
ENTRY_POINT=$(jq -r '.transactions[] | select(.contractName == "EntryPoint") | .contractAddress' "$BROADCAST_FILE")
KERNEL=$(jq -r '.transactions[] | select(.contractName == "Kernel") | .contractAddress' "$BROADCAST_FILE")
KERNEL_FACTORY=$(jq -r '.transactions[] | select(.contractName == "KernelFactory") | .contractAddress' "$BROADCAST_FILE")
ECDSA_VALIDATOR=$(jq -r '.transactions[] | select(.contractName == "ECDSAValidator") | .contractAddress' "$BROADCAST_FILE")
SIG_VALIDATOR=$(jq -r '.transactions[] | select(.contractName == "UniversalSigValidator") | .contractAddress' "$BROADCAST_FILE")

echo -e "${GREEN}Deployed Contract Addresses:${NC}"
echo "  EntryPoint:             $ENTRY_POINT"
echo "  Kernel Implementation:  $KERNEL"
echo "  KernelFactory:          $KERNEL_FACTORY"
echo "  ECDSAValidator:         $ECDSA_VALIDATOR"
echo "  UniversalSigValidator:  $SIG_VALIDATOR"
echo ""

# Also get the bundler's supported entry point
BUNDLER_URL="http://localhost:4337"
echo "Checking bundler's supported entry points..."
BUNDLER_ENTRYPOINT=$(curl -s "$BUNDLER_URL" -X POST \
    -H "Content-Type: application/json" \
    -d '{"jsonrpc":"2.0","id":1,"method":"eth_supportedEntryPoints","params":[]}' \
    2>/dev/null | jq -r '.result[0]' 2>/dev/null || echo "")

if [[ -n "$BUNDLER_ENTRYPOINT" && "$BUNDLER_ENTRYPOINT" != "null" ]]; then
    echo -e "${GREEN}Bundler Entry Point:${NC} $BUNDLER_ENTRYPOINT"
    # Use bundler's entry point as it's what the bundler will accept
    ENTRY_POINT="$BUNDLER_ENTRYPOINT"
    echo -e "${YELLOW}Note: Using bundler's entry point for AA_ENTRY_POINT${NC}"
else
    echo -e "${YELLOW}Warning: Could not reach bundler at $BUNDLER_URL${NC}"
fi
echo ""

# Function to update or add env variable
update_env_var() {
    local var_name="$1"
    local var_value="$2"
    local env_file="$3"
    
    if [[ -z "$var_value" || "$var_value" == "null" ]]; then
        return
    fi

    if grep -q "^${var_name}=" "$env_file" 2>/dev/null; then
        # Variable exists, update it
        if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i '' "s|^${var_name}=.*|${var_name}=${var_value}|" "$env_file"
        else
            sed -i "s|^${var_name}=.*|${var_name}=${var_value}|" "$env_file"
        fi
    else
        # Variable doesn't exist, append it
        echo "${var_name}=${var_value}" >> "$env_file"
    fi
}

# Ensure backend/.env exists
if [[ ! -f "$BACKEND_ENV" ]]; then
    echo "Creating $BACKEND_ENV..."
    touch "$BACKEND_ENV"
fi

# Update backend/.env
echo "Updating $BACKEND_ENV..."
update_env_var "AA_ENTRY_POINT" "$ENTRY_POINT" "$BACKEND_ENV"
update_env_var "AA_FACTORY" "$KERNEL_FACTORY" "$BACKEND_ENV"
update_env_var "AA_KERNEL" "$KERNEL" "$BACKEND_ENV"
update_env_var "AA_ECDSA_VALIDATOR" "$ECDSA_VALIDATOR" "$BACKEND_ENV"
update_env_var "AA_SIG_VALIDATOR" "$SIG_VALIDATOR" "$BACKEND_ENV"
update_env_var "AA_CHAIN_ID" "31337" "$BACKEND_ENV"
update_env_var "AA_BUNDLER" "http://localhost:4337" "$BACKEND_ENV"

echo -e "${GREEN}✓ backend/.env updated${NC}"
echo ""

# Create a web/.env.local if it doesn't exist (for frontend)
WEB_ENV_LOCAL="$PROJECT_ROOT/web/.env.local"
if [[ ! -f "$WEB_ENV_LOCAL" ]]; then
    echo "Creating $WEB_ENV_LOCAL..."
    cat > "$WEB_ENV_LOCAL" << EOF
# Local AA Development Configuration
# Generated by scripts/update-aa-config.sh

# Chain ID for local Anvil
NEXT_PUBLIC_CHAIN_ID=31337

# Disable ZeroDev for local development
# NEXT_PUBLIC_ZERODEV_PROJECT_ID=

# API URL
NEXT_PUBLIC_API_URL=http://localhost:3001
EOF
    echo -e "${GREEN}✓ web/.env.local created${NC}"
else
    echo -e "${YELLOW}web/.env.local already exists, not overwriting${NC}"
fi
echo ""

# Print summary
echo "=== Configuration Complete ==="
echo ""
echo "Backend .env now contains:"
grep -E "^AA_" "$BACKEND_ENV" | sed 's/^/  /'
echo ""
echo -e "${GREEN}Remember to restart services to pick up new config:${NC}"
echo "  • Backend: make backend-dev"
echo "  • Frontend: make web-dev-local"
echo ""
