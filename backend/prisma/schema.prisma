generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String       @id @default(uuid())
  email       String       @unique
  createdAt   DateTime     @default(now())
  artist      Artist?
  agentConfig AgentConfig?
  folders       Folder[]
  libraryTracks LibraryTrack[]
  playlists     Playlist[]
  sessions      Session[]
  wallet        Wallet?
  sessionKeys   SessionKey[]
}

model Wallet {
  id               String  @id @default(uuid())
  userId           String  @unique
  address          String
  chainId          Int
  balanceUsd       Float   @default(0)
  monthlyCapUsd    Float   @default(0)
  spentUsd         Float   @default(0)
  accountType      String  @default("local")
  provider         String  @default("local")
  ownerAddress     String?
  entryPoint       String?
  factory          String?
  paymaster        String?
  bundler          String?
  salt             String?
  deploymentTxHash String?
  pubKeyX          String?
  pubKeyY          String?
  user             User    @relation(fields: [userId], references: [id])
}

model Artist {
  id            String    @id @default(uuid())
  userId        String    @unique
  displayName   String
  payoutAddress String
  user          User      @relation(fields: [userId], references: [id])
  releases      Release[]
}

model Release {
  id              String    @id @default(uuid())
  artistId        String
  title           String
  status          String    @default("processing")
  type            String    @default("single")
  primaryArtist   String?
  featuredArtists String?
  genre           String?
  label           String?
  releaseDate     DateTime?
  explicit        Boolean   @default(false)
  createdAt       DateTime  @default(now())
  artworkUrl      String?
  artworkData     Bytes?
  artworkMimeType String?
  artist          Artist    @relation(fields: [artistId], references: [id])
  tracks          Track[]
}

model Track {
  id               String    @id @default(uuid())
  title            String
  isrc             String?
  explicit         Boolean   @default(false)
  createdAt        DateTime  @default(now())
  position         Int       @default(1)
  releaseId        String
  artist           String?
  processingStatus String    @default("pending") // pending, processing, complete, failed
  licenses         License[]
  stems            Stem[]
  release          Release   @relation(fields: [releaseId], references: [id])
}


model Stem {
  id                 String        @id @default(uuid())
  trackId            String
  type               String
  uri                String
  ipnftId            String?
  checksum           String?
  artist             String?
  artworkUrl         String?
  title              String?
  data               Bytes?
  mimeType           String?
  durationSeconds    Float?
  encryptionMetadata String?
  isEncrypted        Boolean       @default(false)
  storageProvider    String        @default("local")
  track              Track         @relation(fields: [trackId], references: [id])
  listings           StemListing[]
  nftMint            StemNftMint?
  pricing            StemPricing?
}

model StemPricing {
  id                       String   @id @default(uuid())
  stemId                   String   @unique
  basePlayPriceUsd         Float    @default(0.05)
  remixLicenseUsd          Float    @default(5.0)
  commercialLicenseUsd     Float    @default(25.0)
  floorUsd                 Float    @default(0.01)
  ceilingUsd               Float    @default(50.0)
  listingDurationDays      Int?
  createdAt                DateTime @default(now())
  updatedAt                DateTime @updatedAt
  stem                     Stem     @relation(fields: [stemId], references: [id])
}

model StemNftMint {
  id              String   @id @default(uuid())
  stemId          String   @unique
  tokenId         BigInt
  chainId         Int
  contractAddress String
  creatorAddress  String
  royaltyBps      Int
  remixable       Boolean
  metadataUri     String
  transactionHash String   @unique
  blockNumber     BigInt
  mintedAt        DateTime
  createdAt       DateTime @default(now())
  stem            Stem     @relation(fields: [stemId], references: [id])

  @@index([tokenId, chainId])
  @@index([creatorAddress])
}

model StemListing {
  id              String         @id @default(uuid())
  listingId       BigInt
  stemId          String?
  tokenId         BigInt
  chainId         Int
  contractAddress String
  sellerAddress   String
  pricePerUnit    String
  amount          BigInt
  paymentToken    String
  expiresAt       DateTime
  transactionHash String         @unique
  blockNumber     BigInt
  status          String         @default("active")
  listedAt        DateTime
  soldAt          DateTime?
  cancelledAt     DateTime?
  createdAt       DateTime       @default(now())
  stem            Stem?          @relation(fields: [stemId], references: [id])
  purchases       StemPurchase[]

  @@index([listingId, chainId])
  @@index([sellerAddress])
  @@index([tokenId, chainId])
  @@index([status])
}

// License type enum â€” matches RFC #310 License NFT Schema
// Phase 1 uses personal/remix/commercial; others reserved for Phase 4+
enum LicenseType {
  personal
  remix
  commercial
  sync
  sample
  broadcast
}

model StemPurchase {
  id              String      @id @default(uuid())
  listingId       String
  buyerAddress    String
  amount          BigInt
  totalPaid       String
  royaltyPaid     String
  protocolFeePaid String
  sellerReceived  String
  licenseType     LicenseType @default(personal)
  transactionHash String      @unique
  blockNumber     BigInt
  purchasedAt     DateTime
  createdAt       DateTime    @default(now())
  listing         StemListing @relation(fields: [listingId], references: [id])

  @@index([buyerAddress])
  @@index([purchasedAt])
  @@index([licenseType])
}

model RoyaltyPayment {
  id               String   @id @default(uuid())
  tokenId          BigInt
  chainId          Int
  recipientAddress String
  amount           String
  transactionHash  String
  blockNumber      BigInt
  paidAt           DateTime
  createdAt        DateTime @default(now())

  @@unique([transactionHash, tokenId], name: "transactionHash_tokenId")
  @@index([recipientAddress])
  @@index([tokenId, chainId])
  @@index([paidAt])
}

model ContractEvent {
  id              String    @id @default(uuid())
  eventName       String
  chainId         Int
  contractAddress String
  transactionHash String
  logIndex        Int
  blockNumber     BigInt
  blockHash       String
  args            Json
  processedAt     DateTime?
  createdAt       DateTime  @default(now())

  @@unique([transactionHash, logIndex])
  @@index([eventName])
  @@index([blockNumber])
  @@index([contractAddress, chainId])
}

model IndexerState {
  id              String   @id @default(uuid())
  chainId         Int      @unique
  lastBlockNumber BigInt   @default(0)
  updatedAt       DateTime @updatedAt
}

model Session {
  id                String             @id @default(uuid())
  userId            String
  budgetCapUsd      Float
  spentUsd          Float              @default(0)
  startedAt         DateTime           @default(now())
  endedAt           DateTime?
  licenses          License[]
  payments          Payment[]
  agentTransactions AgentTransaction[]
  user              User               @relation(fields: [userId], references: [id])
}

model AgentTransaction {
  id            String    @id @default(uuid())
  sessionId     String
  userId        String
  listingId     BigInt
  tokenId       BigInt
  amount        BigInt
  totalPriceWei String
  priceUsd      Float
  txHash        String?
  userOpHash    String?
  status        String    @default("pending")
  errorMessage  String?
  createdAt     DateTime  @default(now())
  confirmedAt   DateTime?
  session       Session   @relation(fields: [sessionId], references: [id])

  @@index([sessionId])
  @@index([userId])
  @@index([status])
}

model License {
  id              String  @id @default(uuid())
  sessionId       String
  trackId         String
  type            String
  priceUsd        Float
  durationSeconds Int
  session         Session @relation(fields: [sessionId], references: [id])
  track           Track   @relation(fields: [trackId], references: [id])
}

model Payment {
  id        String  @id @default(uuid())
  sessionId String
  txHash    String?
  amountUsd Float
  status    String
  session   Session @relation(fields: [sessionId], references: [id])
}

model Playlist {
  id        String   @id @default(uuid())
  userId    String
  name      String
  trackIds  String[]
  folderId  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  folder    Folder?  @relation(fields: [folderId], references: [id])
  user      User     @relation(fields: [userId], references: [id])
}

model Folder {
  id        String     @id @default(uuid())
  userId    String
  name      String
  createdAt DateTime   @default(now())
  user      User       @relation(fields: [userId], references: [id])
  playlists Playlist[]
}

model AgentConfig {
  id            String   @id @default(uuid())
  userId        String   @unique
  name          String   @default("My DJ")
  vibes         String[] @default(["Focus"])
  sessionMode   String   @default("curate") // "curate" | "buy"
  stemTypes     String[] @default([])
  monthlyCapUsd Float    @default(10)
  isActive      Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  user          User     @relation(fields: [userId], references: [id])
}

model SessionKey {
  id              String    @id @default(uuid())
  userId          String
  serializedKey   String    @db.Text
  permissions     Json      // {target, function, totalCap, perTxCap, rateLimit}
  validUntil      DateTime
  revokedAt       DateTime?
  txHash          String?
  revokeTxHash    String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  user            User      @relation(fields: [userId], references: [id])

  @@index([userId])
}

model LibraryTrack {
  id               String    @id @default(uuid())
  userId           String
  source           String    @default("local") // "local" | "remote"

  // Core metadata
  title            String
  artist           String?
  albumArtist      String?
  album            String?
  year             Int?
  genre            String?
  duration         Float?

  // Local source fields
  sourcePath       String?
  fileSize         Int?

  // Remote source fields
  catalogTrackId   String?
  remoteUrl        String?
  remoteArtworkUrl String?

  // Stem ownership
  stemType         String?
  tokenId          String?
  listingId        String?
  purchaseDate     DateTime?
  isOwned          Boolean   @default(false)
  previewUrl       String?

  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  user             User      @relation(fields: [userId], references: [id])

  @@unique([userId, sourcePath, fileSize])
  @@unique([userId, catalogTrackId])
  @@index([userId])
}
