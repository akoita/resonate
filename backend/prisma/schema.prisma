generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String     @id @default(uuid())
  email     String     @unique
  createdAt DateTime   @default(now())
  artist    Artist?
  folders   Folder[]
  playlists Playlist[]
  sessions  Session[]
  wallet    Wallet?
}

model Wallet {
  id               String  @id @default(uuid())
  userId           String  @unique
  address          String
  chainId          Int
  balanceUsd       Float   @default(0)
  monthlyCapUsd    Float   @default(0)
  spentUsd         Float   @default(0)
  accountType      String  @default("local")
  provider         String  @default("local")
  ownerAddress     String?
  entryPoint       String?
  factory          String?
  paymaster        String?
  bundler          String?
  salt             String?
  deploymentTxHash String?
  user             User    @relation(fields: [userId], references: [id])
}

model Artist {
  id            String    @id @default(uuid())
  userId        String    @unique
  displayName   String
  payoutAddress String
  user          User      @relation(fields: [userId], references: [id])
  releases      Release[]
}

model Release {
  id              String    @id @default(uuid())
  artistId        String
  title           String
  status          String    @default("processing")
  type            String    @default("single")
  primaryArtist   String?
  featuredArtists String?
  genre           String?
  label           String?
  releaseDate     DateTime?
  explicit        Boolean   @default(false)
  createdAt       DateTime  @default(now())
  artworkUrl      String?
  artworkData     Bytes?
  artworkMimeType String?
  artist          Artist    @relation(fields: [artistId], references: [id])
  tracks          Track[]
}

model Track {
  id               String    @id @default(uuid())
  title            String
  isrc             String?
  explicit         Boolean   @default(false)
  createdAt        DateTime  @default(now())
  position         Int       @default(1)
  releaseId        String
  artist           String?
  processingStatus String    @default("pending") // pending, processing, complete, failed
  licenses         License[]
  stems            Stem[]
  release          Release   @relation(fields: [releaseId], references: [id])
}


model Stem {
  id                 String        @id @default(uuid())
  trackId            String
  type               String
  uri                String
  ipnftId            String?
  checksum           String?
  artist             String?
  artworkUrl         String?
  title              String?
  data               Bytes?
  mimeType           String?
  durationSeconds    Float?
  encryptionMetadata String?
  isEncrypted        Boolean       @default(false)
  storageProvider    String        @default("local")
  track              Track         @relation(fields: [trackId], references: [id])
  listings           StemListing[]
  nftMint            StemNftMint?
}

model StemNftMint {
  id              String   @id @default(uuid())
  stemId          String   @unique
  tokenId         BigInt
  chainId         Int
  contractAddress String
  creatorAddress  String
  royaltyBps      Int
  remixable       Boolean
  metadataUri     String
  transactionHash String   @unique
  blockNumber     BigInt
  mintedAt        DateTime
  createdAt       DateTime @default(now())
  stem            Stem     @relation(fields: [stemId], references: [id])

  @@index([tokenId, chainId])
  @@index([creatorAddress])
}

model StemListing {
  id              String         @id @default(uuid())
  listingId       BigInt
  stemId          String?
  tokenId         BigInt
  chainId         Int
  contractAddress String
  sellerAddress   String
  pricePerUnit    String
  amount          BigInt
  paymentToken    String
  expiresAt       DateTime
  transactionHash String         @unique
  blockNumber     BigInt
  status          String         @default("active")
  listedAt        DateTime
  soldAt          DateTime?
  cancelledAt     DateTime?
  createdAt       DateTime       @default(now())
  stem            Stem?          @relation(fields: [stemId], references: [id])
  purchases       StemPurchase[]

  @@index([listingId, chainId])
  @@index([sellerAddress])
  @@index([tokenId, chainId])
  @@index([status])
}

model StemPurchase {
  id              String      @id @default(uuid())
  listingId       String
  buyerAddress    String
  amount          BigInt
  totalPaid       String
  royaltyPaid     String
  protocolFeePaid String
  sellerReceived  String
  transactionHash String      @unique
  blockNumber     BigInt
  purchasedAt     DateTime
  createdAt       DateTime    @default(now())
  listing         StemListing @relation(fields: [listingId], references: [id])

  @@index([buyerAddress])
  @@index([purchasedAt])
}

model RoyaltyPayment {
  id               String   @id @default(uuid())
  tokenId          BigInt
  chainId          Int
  recipientAddress String
  amount           String
  transactionHash  String
  blockNumber      BigInt
  paidAt           DateTime
  createdAt        DateTime @default(now())

  @@unique([transactionHash, tokenId], name: "transactionHash_tokenId")
  @@index([recipientAddress])
  @@index([tokenId, chainId])
  @@index([paidAt])
}

model ContractEvent {
  id              String    @id @default(uuid())
  eventName       String
  chainId         Int
  contractAddress String
  transactionHash String
  logIndex        Int
  blockNumber     BigInt
  blockHash       String
  args            Json
  processedAt     DateTime?
  createdAt       DateTime  @default(now())

  @@unique([transactionHash, logIndex])
  @@index([eventName])
  @@index([blockNumber])
  @@index([contractAddress, chainId])
}

model IndexerState {
  id              String   @id @default(uuid())
  chainId         Int      @unique
  lastBlockNumber BigInt   @default(0)
  updatedAt       DateTime @updatedAt
}

model Session {
  id           String    @id @default(uuid())
  userId       String
  budgetCapUsd Float
  spentUsd     Float     @default(0)
  startedAt    DateTime  @default(now())
  endedAt      DateTime?
  licenses     License[]
  payments     Payment[]
  user         User      @relation(fields: [userId], references: [id])
}

model License {
  id              String  @id @default(uuid())
  sessionId       String
  trackId         String
  type            String
  priceUsd        Float
  durationSeconds Int
  session         Session @relation(fields: [sessionId], references: [id])
  track           Track   @relation(fields: [trackId], references: [id])
}

model Payment {
  id        String  @id @default(uuid())
  sessionId String
  txHash    String?
  amountUsd Float
  status    String
  session   Session @relation(fields: [sessionId], references: [id])
}

model Playlist {
  id        String   @id @default(uuid())
  userId    String
  name      String
  trackIds  String[]
  folderId  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  folder    Folder?  @relation(fields: [folderId], references: [id])
  user      User     @relation(fields: [userId], references: [id])
}

model Folder {
  id        String     @id @default(uuid())
  userId    String
  name      String
  createdAt DateTime   @default(now())
  user      User       @relation(fields: [userId], references: [id])
  playlists Playlist[]
}
